TITLE: Accessing Flask current_app in Blueprints
DESCRIPTION: Illustrates how to access the application's configuration via `current_app` within a blueprint's view function. This is necessary because the application object is not available at import time when using factories, but `current_app` provides access during a request.
CODE:
```
from flask import current_app, Blueprint, render_template
admin = Blueprint('admin', __name__, url_prefix='/admin')

@admin.route('/')
def index():
    return render_template(current_app.config['INDEX_TEMPLATE'])
```

---

TITLE: Creating a Basic Flask Application Factory
DESCRIPTION: Demonstrates the fundamental structure of a Flask application factory. This function initializes the Flask app, loads configuration, initializes a database extension, registers blueprints, and returns the configured application instance.
CODE:
```
def create_app(config_filename):
    app = Flask(__name__)
    app.config.from_pyfile(config_filename)

    from yourapplication.model import db
    db.init_app(app)

    from yourapplication.views.admin import admin
    from yourapplication.views.frontend import frontend
    app.register_blueprint(admin)
    app.register_blueprint(frontend)

    return app
```

---

TITLE: Register Flask Blueprint in Application Factory (Python)
DESCRIPTION: This Python snippet demonstrates how to integrate a Flask Blueprint (auth.bp) into the main application. It shows importing the blueprint module and registering it using `app.register_blueprint()` within the `create_app` factory function, ensuring the blueprint's routes are active.
CODE:
```
def create_app():
    app = ...
    # existing code omitted

    from . import auth
    app.register_blueprint(auth.bp)

    return app
```

---

TITLE: Define Flask Application Factory (Python)
DESCRIPTION: This Python function `create_app` serves as the application factory for a Flask application. It initializes the Flask instance, configures default settings, handles instance-relative configuration, ensures the instance folder exists, and sets up a basic '/hello' route. This pattern is recommended for robust application structures, especially for testing and deployment.
CODE:
```
import os

from flask import Flask


def create_app(test_config=None):
    # create and configure the app
    app = Flask(__name__, instance_relative_config=True)
    app.config.from_mapping(
        SECRET_KEY='dev',
        DATABASE=os.path.join(app.instance_path, 'flaskr.sqlite'),
    )

    if test_config is None:
        # load the instance config, if it exists, when not testing
        app.config.from_pyfile('config.py', silent=True)
    else:
        # load the test config if passed in
        app.config.from_mapping(test_config)

    # ensure the instance folder exists
    try:
        os.makedirs(app.instance_path)
    except OSError:
        pass

    # a simple page that says hello
    @app.route('/hello')
    def hello():
        return 'Hello, World!'

    return app
```

---

TITLE: Flask Application Configuration API Reference
DESCRIPTION: Detailed API documentation for key components and methods used in configuring a Flask application, including the Flask class constructor, configuration methods, and routing decorators.
CODE:
```
Flask Class Constructor:
  Flask(__name__, instance_relative_config=True)
    __name__: The name of the current Python module, used by Flask to locate paths.
    instance_relative_config: bool - If True, configuration files are relative to the instance folder, which is outside the package and holds local data (e.g., secrets, database).

Config Object Methods and Attributes:
  app.config.from_mapping(mapping: dict)
    Purpose: Sets default configuration values for the application.
    Parameters:
      mapping: A dictionary of configuration key-value pairs.
    Attributes:
      SECRET_KEY: Used by Flask and extensions for data safety. Default 'dev' for development; should be overridden in production.
      DATABASE: Path where the SQLite database file will be saved, typically under app.instance_path.

  app.config.from_pyfile(filename: str, silent: bool = False)
    Purpose: Overrides default configuration with values from a Python file in the instance folder.
    Parameters:
      filename: The name of the Python file (e.g., 'config.py').
      silent: bool - If True, errors are ignored if the file doesn't exist.

Flask Instance Attributes:
  app.instance_path: The path Flask has chosen for the instance folder. This folder is not created automatically and must be ensured to exist (e.g., using os.makedirs).

Routing Decorators:
  @app.route(rule: str, **options)
    Purpose: Creates a connection between a URL rule and a function that returns a response.
    Parameters:
      rule: The URL rule string (e.g., '/hello').
    Usage: Applied as a decorator to a Python function, making that function handle requests to the specified URL.
```

---

TITLE: Running Flask Application with Factory Arguments
DESCRIPTION: Illustrates how to pass keyword arguments to a Flask application factory directly from the command line. This allows for dynamic configuration of the application instance at runtime.
CODE:
```
$ flask --app 'hello:create_app(local_auth=True)' run
```

---

TITLE: Inspect Flask Application URL Map After Blueprint Registration
DESCRIPTION: This snippet illustrates how to inspect the URL routing map of a Flask application after a blueprint has been registered. It shows that blueprint-defined routes are prefixed with the blueprint's name (e.g., `simple_page.show`), distinguishing them from application-level routes.
CODE:
```
>>> app.url_map
Map([<Rule '/static/<filename>' (HEAD, OPTIONS, GET) -> static>,
     <Rule '/<page>' (HEAD, OPTIONS, GET) -> simple_page.show>,
     <Rule '/' (HEAD, OPTIONS, GET) -> simple_page.show>])
```

---

TITLE: Register a Flask Blueprint with an Application
DESCRIPTION: This example shows how to integrate a previously defined Flask Blueprint, `simple_page`, into a main Flask application. It imports the blueprint and registers it using the `app.register_blueprint()` method, making its routes available to the application.
CODE:
```
from flask import Flask
from yourapplication.simple_page import simple_page

app = Flask(__name__)
app.register_blueprint(simple_page)
```

---

TITLE: Register a Flask Blueprint with a URL Prefix
DESCRIPTION: This code demonstrates how to register a Flask Blueprint at a specific URL prefix, such as '/pages'. By providing `url_prefix` to `app.register_blueprint()`, all routes defined within the blueprint will automatically be prepended with this path.
CODE:
```
app.register_blueprint(simple_page, url_prefix='/pages')
```

---

TITLE: Register Blog Blueprint in Flask Application Factory
DESCRIPTION: This code demonstrates how to register the 'blog' Blueprint within the Flask application factory (`create_app` function in `flaskr/__init__.py`). It imports the blog module and uses `app.register_blueprint()` to integrate it, also setting the root URL '/' to the 'index' endpoint so that `url_for('index')` or `url_for('blog.index')` both resolve to '/'.
CODE:
```
def create_app():
    app = ...
    # existing code omitted

    from . import blog
    app.register_blueprint(blog.bp)
    app.add_url_rule('/', endpoint='index')

    return app
```

---

TITLE: Inspect Flask Application URL Map After Prefix Registration
DESCRIPTION: This snippet shows the updated URL map of a Flask application when a blueprint is registered with a `url_prefix`. It confirms that the routes defined by the blueprint now include the specified prefix, such as '/pages/<page>', effectively mounting the blueprint's functionality under a new base URL.
CODE:
```
>>> app.url_map
Map([<Rule '/static/<filename>' (HEAD, OPTIONS, GET) -> static>,
     <Rule '/pages/<page>' (HEAD, OPTIONS, GET) -> simple_page.show>,
     <Rule '/pages/' (HEAD, OPTIONS, GET) -> simple_page.show>])
```

---

TITLE: Configuring Static Files for a Blueprint
DESCRIPTION: Illustrates how to expose a folder with static files for a Blueprint by providing the `static_folder` argument during Blueprint initialization. The path can be absolute or relative.
CODE:
```
admin = Blueprint('admin', __name__, static_folder='static')
```

---

TITLE: Configuring Template Folder for a Blueprint
DESCRIPTION: Shows how to specify a template folder for a Blueprint using the `template_folder` parameter in the Blueprint constructor. Templates in this folder are added to the search path with lower priority than the application's templates.
CODE:
```
admin = Blueprint('admin', __name__, template_folder='templates')
```

---

TITLE: Basic Flask Application Setup and Configuration
DESCRIPTION: This snippet demonstrates the initial setup of a Flask application by creating an instance of the Flask class. It shows how to configure the application using `app.config.from_mapping` for default settings and `app.config.from_prefixed_env()` for environment-based configuration. A basic route is also included to illustrate a simple 'Hello, World!' endpoint.
CODE:
```
from flask import Flask

app = Flask(__name__)
app.config.from_mapping(
    SECRET_KEY="dev",
)
app.config.from_prefixed_env()

@app.route("/")
def index():
    return "Hello, World!"
```

---

TITLE: Define a Basic Flask Blueprint for Static Pages
DESCRIPTION: This snippet demonstrates how to create a Flask Blueprint named 'simple_page'. It defines routes for a root path and a dynamic page, serving static HTML templates from a 'templates' folder. The code includes error handling for TemplateNotFound to return a 404 error.
CODE:
```
from flask import Blueprint, render_template, abort
from jinja2 import TemplateNotFound

simple_page = Blueprint('simple_page', __name__,
                            template_folder='templates')

@simple_page.route('/', defaults={'page': 'index'})
@simple_page.route('/<page>')
def show(page):
    try:
        return render_template(f'pages/{page}.html')
    except TemplateNotFound:
        abort(404)
```

---

TITLE: Opening Resources from a Blueprint
DESCRIPTION: Shows how to use the `open_resource` method of a Blueprint to open files relative to its resource folder, such as static assets or configuration files.
CODE:
```
with simple_page.open_resource('static/style.css') as f:
    code = f.read()
```

---

TITLE: Create Flask Project Directory
DESCRIPTION: This command creates the root directory for the Flask application, which will contain the application package and instance folder.
CODE:
```
$ mkdir flaskr
```

---

TITLE: Generating URLs for Blueprint Static Files
DESCRIPTION: Demonstrates how to use `url_for` to generate URLs for static files exposed by a Blueprint, using the `blueprint_name.static` endpoint.
CODE:
```
url_for('admin.static', filename='style.css')
```

---

TITLE: Running Flask Application with Default Factory
DESCRIPTION: Provides the command-line instruction to run a Flask application that uses an application factory. Flask automatically detects factories named `create_app` or `make_app` in the specified module.
CODE:
```
$ flask --app hello run
```

---

TITLE: Correct Flask Extension Initialization in Factory
DESCRIPTION: Demonstrates the preferred method for initializing Flask extensions within an application factory. By creating the extension object unbound and then calling `init_app(app)` inside the factory, the extension remains decoupled from the application, allowing a single extension object to be used with multiple app instances.
CODE:
```
db.init_app(app)
```

---

TITLE: Generating URLs for Nested Blueprints
DESCRIPTION: Shows how `url_for` generates a URL for an endpoint within a nested blueprint, reflecting the combined URL prefixes of parent and child blueprints.
CODE:
```
url_for('parent.child.create')
/parent/child/create
```

---

TITLE: Incorrect Flask Extension Initialization in Factory
DESCRIPTION: Shows an example of an incorrect way to initialize a Flask extension (Flask-SQLAlchemy) within an application factory. Binding the extension directly to the app (`SQLAlchemy(app)`) prevents the extension object from being reusable across multiple application instances.
CODE:
```
db = SQLAlchemy(app)
```

---

TITLE: Flask Blueprint URL Generation (Relative)
DESCRIPTION: Shows how to generate a relative URL for an endpoint within the same Flask Blueprint, useful when linking between views of the same blueprint without explicitly naming it.
CODE:
```
url_for('.index')
```

---

TITLE: Handling Subdomains with Nested Blueprints
DESCRIPTION: Illustrates how subdomains are handled when nesting blueprints, where the child's subdomain prefixes the parent's in the final URL.
CODE:
```
parent = Blueprint('parent', __name__, subdomain='parent')
child = Blueprint('child', __name__, subdomain='child')
parent.register_blueprint(child)
app.register_blueprint(parent)

url_for('parent.child.create', _external=True)
"child.parent.domain.tld"
```

---

TITLE: Accessing Blueprint Root Path
DESCRIPTION: Demonstrates how to access the `root_path` property of a Flask Blueprint to determine its resource folder on the filesystem.
CODE:
```
simple_page.root_path
'/Users/username/TestProject/yourapplication'
```

---

TITLE: Configure uWSGI with Flask app factory pattern
DESCRIPTION: This snippet illustrates how to run uWSGI with a Flask application that uses the app factory pattern. It includes a Python file (`wsgi.py`) to create the application instance and the corresponding `uwsgi` command to point to this file.
CODE:
```
from hello import create_app

app = create_app()
```

---

TITLE: Registering a Child Blueprint on a Parent Blueprint
DESCRIPTION: Demonstrates how to register a child Blueprint on a parent Blueprint in Flask. The child's name and URLs will automatically gain the parent's prefix.
CODE:
```
parent = Blueprint('parent', __name__, url_prefix='/parent')
child = Blueprint('child', __name__, url_prefix='/child')
parent.register_blueprint(child)
app.register_blueprint(parent)
```

---

TITLE: Flask Blueprint URL Generation (Absolute)
DESCRIPTION: Demonstrates how to generate a URL for an endpoint within a specific Flask Blueprint using the `url_for` function, by prefixing the endpoint with the blueprint name and a dot.
CODE:
```
url_for('admin.index')
```

---

TITLE: Manually Push Flask Application Context for Initialization
DESCRIPTION: This Python snippet demonstrates how to manually push an application context using `app.app_context()` within a `with` block. This is useful during application configuration, such as initializing a database, especially when using the app factory pattern where the `app` instance is not globally imported.
CODE:
```
def create_app():
        app = Flask(__name__)

        with app.app_context():
            init_db()

        return app
```

---

TITLE: Flask: Application-level 404 Handler for Blueprint URL Errors
DESCRIPTION: This Python snippet highlights that 404/405 error handlers defined on blueprints are only triggered by explicit `raise` or `abort` calls within the blueprint's views. For invalid URLs not owned by a blueprint, the handler must be defined at the application level to catch all such errors.
CODE:
```
from flask import jsonify, render_template

# at the application level
# not the blueprint level
@app.errorhandler(404)
```

---

TITLE: Flask Internal Context and Blueprint API
DESCRIPTION: This section documents internal Flask objects crucial for request and application context management, as well as blueprint setup. These are typically not directly accessed by application developers.
CODE:
```
class flask.ctx.RequestContext
data flask.globals.request_ctx:
  The current RequestContext. If a request context is not active, accessing attributes on this proxy will raise a RuntimeError.
  This is an internal object that is essential to how Flask handles requests. Accessing this should not be needed in most cases. Most likely you want request and session instead.

class flask.ctx.AppContext
data flask.globals.app_ctx:
  The current AppContext. If an app context is not active, accessing attributes on this proxy will raise a RuntimeError.
  This is an internal object that is essential to how Flask handles requests. Accessing this should not be needed in most cases. Most likely you want current_app and g instead.

class flask.blueprints.BlueprintSetupState
```

---

TITLE: Test Flask Application Configuration and Hello Route
DESCRIPTION: Tests the Flask application's configuration, ensuring the 'TESTING' flag works correctly, and verifies a basic 'hello' route returns the expected 'Hello, World!' response using the test client.
CODE:
```
from flaskr import create_app


def test_config():
    assert not create_app().testing
    assert create_app({'TESTING': True}).testing


def test_hello(client):
    response = client.get('/hello')
    assert response.data == b'Hello, World!'
