[
  {
    "TITLE": "Accessing Flask current_app in Blueprints",
    "DESCRIPTION": "Illustrates how to access the application's configuration via `current_app` within a blueprint's view function. This is necessary because the application object is not available at import time when using factories, but `current_app` provides access during a request.",
    "LANGUAGE": "python",
    "CODE": "```\nfrom flask import current_app, Blueprint, render_template\nadmin = Blueprint('admin', __name__, url_prefix='/admin')\n\n@admin.route('/')\ndef index():\n    return render_template(current_app.config['INDEX_TEMPLATE'])\n```"
  },
  {
    "TITLE": "Creating a Basic Flask Application Factory",
    "DESCRIPTION": "Demonstrates the fundamental structure of a Flask application factory. This function initializes the Flask app, loads configuration, initializes a database extension, registers blueprints, and returns the configured application instance.",
    "LANGUAGE": "python",
    "CODE": "```\ndef create_app(config_filename):\n    app = Flask(__name__)\n    app.config.from_pyfile(config_filename)\n\n    from yourapplication.model import db\n    db.init_app(app)\n\n    from yourapplication.views.admin import admin\n    from yourapplication.views.frontend import frontend\n    app.register_blueprint(admin)\n    app.register_blueprint(frontend)\n\n    return app\n```"
  },
  {
    "TITLE": "Register Flask Blueprint in Application Factory (Python)",
    "DESCRIPTION": "This Python snippet demonstrates how to integrate a Flask Blueprint (auth.bp) into the main application. It shows importing the blueprint module and registering it using `app.register_blueprint()` within the `create_app` factory function, ensuring the blueprint's routes are active.",
    "LANGUAGE": "python",
    "CODE": "```\ndef create_app():\n    app = ...\n    # existing code omitted\n\n    from . import auth\n    app.register_blueprint(auth.bp)\n\n    return app\n```"
  },
  {
    "TITLE": "Define Flask Application Factory (Python)",
    "DESCRIPTION": "This Python function `create_app` serves as the application factory for a Flask application. It initializes the Flask instance, configures default settings, handles instance-relative configuration, ensures the instance folder exists, and sets up a basic '/hello' route. This pattern is recommended for robust application structures, especially for testing and deployment.",
    "LANGUAGE": "python",
    "CODE": "```\nimport os\n\nfrom flask import Flask\n\ndef create_app(test_config=None):\n    # create and configure the app\n    app = Flask(__name__, instance_relative_config=True)\n    app.config.from_mapping(\n        SECRET_KEY='dev',\n        DATABASE=os.path.join(app.instance_path, 'flaskr.sqlite'),\n    )\n\n    if test_config is None:\n        # load the instance config, if it exists, when not testing\n        app.config.from_pyfile('config.py', silent=True)\n    else:\n        # load the test config if passed in\n        app.config.from_mapping(test_config)\n\n    # ensure the instance folder exists\n    try:\n        os.makedirs(app.instance_path)\n    except OSError:\n        pass\n\n    # a simple page that says hello\n    @app.route('/hello')\n    def hello():\n        return 'Hello, World!'\n\n    return app\n```"
  },
  {
    "TITLE": "Flask Application Configuration API Reference",
    "DESCRIPTION": "Detailed API documentation for key components and methods used in configuring a Flask application, including the Flask class constructor, configuration methods, and routing decorators.",
    "LANGUAGE": "APIDOC",
    "CODE": "```\nFlask Class Constructor:\n  Flask(__name__, instance_relative_config=True)\n    __name__: The name of the current Python module, used by Flask to locate paths.\n    instance_relative_config: bool - If True, configuration files are relative to the instance folder, which is outside the package and holds local data (e.g., secrets, database).\n\nConfig Object Methods and Attributes:\n  app.config.from_mapping(mapping: dict)\n    Purpose: Sets default configuration values for the application.\n    Parameters:\n      mapping: A dictionary of configuration key-value pairs.\n    Attributes:\n      SECRET_KEY: Used by Flask and extensions for data safety. Default 'dev' for development; should be overridden in production.\n      DATABASE: Path where the SQLite database file will be saved, typically under app.instance_path.\n\n  app.config.from_pyfile(filename: str, silent: bool = False)\n    Purpose: Overrides default configuration with values from a Python file in the instance folder.\n    Parameters:\n      filename: The name of the Python file (e.g., 'config.py').\n      silent: bool - If True, errors are ignored if the file doesn't exist.\n\nFlask Instance Attributes:\n  app.instance_path: The path Flask has chosen for the instance folder. This folder is not created automatically and must be ensured to exist (e.g., using os.makedirs).\n\nRouting Decorators:\n  @app.route(rule: str, **options)\n    Purpose: Creates a connection between a URL rule and a function that returns a response.\n    Parameters:\n      rule: The URL rule string (e.g., '/hello').\n    Usage: Applied as a decorator to a Python function, making that function handle requests to the specified URL.\n```"
  },
  {
    "TITLE": "Running Flask Application with Factory Arguments",
    "DESCRIPTION": "Illustrates how to pass keyword arguments to a Flask application factory directly from the command line. This allows for dynamic configuration of the application instance at runtime.",
    "LANGUAGE": "text",
    "CODE": "```\n$ flask --app 'hello:create_app(local_auth=True)' run\n```"
  },
  {
    "TITLE": "Inspect Flask Application URL Map After Blueprint Registration",
    "DESCRIPTION": "This snippet illustrates how to inspect the URL routing map of a Flask application after a blueprint has been registered. It shows that blueprint-defined routes are prefixed with the blueprint's name (e.g., `simple_page.show`), distinguishing them from application-level routes.",
    "LANGUAGE": "Python",
    "CODE": "```\n>>> app.url_map\nMap([<Rule '/static/<filename>' (HEAD, OPTIONS, GET) -> static>,\n     <Rule '/<page>' (HEAD, OPTIONS, GET) -> simple_page.show>,\n     <Rule '/' (HEAD, OPTIONS, GET) -> simple_page.show>])\n```"
  },
  {
    "TITLE": "Register a Flask Blueprint with an Application",
    "DESCRIPTION": "This example shows how to integrate a previously defined Flask Blueprint, `simple_page`, into a main Flask application. It imports the blueprint and registers it using the `app.register_blueprint()` method, making its routes available to the application.",
    "LANGUAGE": "Python",
    "CODE": "```\nfrom flask import Flask\nfrom yourapplication.simple_page import simple_page\n\napp = Flask(__name__)\napp.register_blueprint(simple_page)\n```"
  },
  {
    "TITLE": "Register a Flask Blueprint with a URL Prefix",
    "DESCRIPTION": "This code demonstrates how to register a Flask Blueprint at a specific URL prefix, such as '/pages'. By providing `url_prefix` to `app.register_blueprint()`, all routes defined within the blueprint will automatically be prepended with this path.",
    "LANGUAGE": "Python",
    "CODE": "```\napp.register_blueprint(simple_page, url_prefix='/pages')\n```"
  },
  {
    "TITLE": "Register Blog Blueprint in Flask Application Factory",
    "DESCRIPTION": "This code demonstrates how to register the 'blog' Blueprint within the Flask application factory (`create_app` function in `flaskr/__init__.py`). It imports the blog module and uses `app.register_blueprint()` to integrate it, also setting the root URL '/' to the 'index' endpoint so that `url_for('index')` or `url_for('blog.index')` both resolve to '/'.",
    "LANGUAGE": "python",
    "CODE": "```\ndef create_app():\n    app = ...\n    # existing code omitted\n\n    from . import blog\n    app.register_blueprint(blog.bp)\n    app.add_url_rule('/', endpoint='index')\n\n    return app\n```"
  },
  {
    "TITLE": "Inspect Flask Application URL Map After Prefix Registration",
    "DESCRIPTION": "This snippet shows the updated URL map of a Flask application when a blueprint is registered with a `url_prefix`. It confirms that the routes defined by the blueprint now include the specified prefix, such as '/pages/<page>', effectively mounting the blueprint's functionality under a new base URL.",
    "LANGUAGE": "Python",
    "CODE": "```\n>>> app.url_map\nMap([<Rule '/static/<filename>' (HEAD, OPTIONS, GET) -> static>,\n     <Rule '/pages/<page>' (HEAD, OPTIONS, GET) -> simple_page.show>,\n     <Rule '/pages/' (HEAD, OPTIONS, GET) -> simple_page.show>])\n```"
  },
  {
    "TITLE": "Configuring Static Files for a Blueprint",
    "DESCRIPTION": "Illustrates how to expose a folder with static files for a Blueprint by providing the `static_folder` argument during Blueprint initialization. The path can be absolute or relative.",
    "LANGUAGE": "python",
    "CODE": "```\nadmin = Blueprint('admin', __name__, static_folder='static')\n```"
  },
  {
    "TITLE": "Configuring Template Folder for a Blueprint",
    "DESCRIPTION": "Shows how to specify a template folder for a Blueprint using the `template_folder` parameter in the Blueprint constructor. Templates in this folder are added to the search path with lower priority than the application's templates.",
    "LANGUAGE": "python",
    "CODE": "```\nadmin = Blueprint('admin', __name__, template_folder='templates')\n```"
  },
  {
    "TITLE": "Basic Flask Application Setup and Configuration",
    "DESCRIPTION": "This snippet demonstrates the initial setup of a Flask application by creating an instance of the Flask class. It shows how to configure the application using `app.config.from_mapping` for default settings and `app.config.from_prefixed_env()` for environment-based configuration. A basic route is also included to illustrate a simple 'Hello, World!' endpoint.",
    "LANGUAGE": "python",
    "CODE": "```\nfrom flask import Flask\n\napp = Flask(__name__)\napp.config.from_mapping(\n    SECRET_KEY=\"dev\",\n)\napp.config.from_prefixed_env()\n\n@app.route(\"/\")\ndef index():\n    return \"Hello, World!\"\n```"
  },
  {
    "TITLE": "Define a Basic Flask Blueprint for Static Pages",
    "DESCRIPTION": "This snippet demonstrates how to create a Flask Blueprint named 'simple_page'. It defines routes for a root path and a dynamic page, serving static HTML templates from a 'templates' folder. The code includes error handling for TemplateNotFound to return a 404 error.",
    "LANGUAGE": "Python",
    "CODE": "```\nfrom flask import Blueprint, render_template, abort\nfrom jinja2 import TemplateNotFound\n\nsimple_page = Blueprint('simple_page', __name__,\n                            template_folder='templates')\n\n@simple_page.route('/', defaults={'page': 'index'})\n@simple_page.route('/<page>')\ndef show(page):\n    try:\n        return render_template(f'pages/{page}.html')\n    except TemplateNotFound:\n        abort(404)\n```"
  },
  {
    "TITLE": "Opening Resources from a Blueprint",
    "DESCRIPTION": "Shows how to use the `open_resource` method of a Blueprint to open files relative to its resource folder, such as static assets or configuration files.",
    "LANGUAGE": "python",
    "CODE": "```\nwith simple_page.open_resource('static/style.css') as f:\n    code = f.read()\n```"
  },
  {
    "TITLE": "Create Flask Project Directory",
    "DESCRIPTION": "This command creates the root directory for the Flask application, which will contain the application package and instance folder.",
    "LANGUAGE": "none",
    "CODE": "```\n$ mkdir flaskr\n```"
  },
  {
    "TITLE": "Generating URLs for Blueprint Static Files",
    "DESCRIPTION": "Demonstrates how to use `url_for` to generate URLs for static files exposed by a Blueprint, using the `blueprint_name.static` endpoint.",
    "LANGUAGE": "python",
    "CODE": "```\nurl_for('admin.static', filename='style.css')\n```"
  },
  {
    "TITLE": "Running Flask Application with Default Factory",
    "DESCRIPTION": "Provides the command-line instruction to run a Flask application that uses an application factory. Flask automatically detects factories named `create_app` or `make_app` in the specified module.",
    "LANGUAGE": "text",
    "CODE": "```\n$ flask --app hello run\n```"
  },
  {
    "TITLE": "Correct Flask Extension Initialization in Factory",
    "DESCRIPTION": "Demonstrates the preferred method for initializing Flask extensions within an application factory. By creating the extension object unbound and then calling `init_app(app)` inside the factory, the extension remains decoupled from the application, allowing a single extension object to be used with multiple app instances.",
    "LANGUAGE": "python",
    "CODE": "```\ndb.init_app(app)\n```"
  },
  {
    "TITLE": "Generating URLs for Nested Blueprints",
    "DESCRIPTION": "Shows how `url_for` generates a URL for an endpoint within a nested blueprint, reflecting the combined URL prefixes of parent and child blueprints.",
    "LANGUAGE": "python",
    "CODE": "```\nurl_for('parent.child.create')\n/parent/child/create\n```"
  },
  {
    "TITLE": "Incorrect Flask Extension Initialization in Factory",
    "DESCRIPTION": "Shows an example of an incorrect way to initialize a Flask extension (Flask-SQLAlchemy) within an application factory. Binding the extension directly to the app (`SQLAlchemy(app)`) prevents the extension object from being reusable across multiple application instances.",
    "LANGUAGE": "python",
    "CODE": "```\ndb = SQLAlchemy(app)\n```"
  },
  {
    "TITLE": "Flask Blueprint URL Generation (Relative)",
    "DESCRIPTION": "Shows how to generate a relative URL for an endpoint within the same Flask Blueprint, useful when linking between views of the same blueprint without explicitly naming it.",
    "LANGUAGE": "python",
    "CODE": "```\nurl_for('.index')\n```"
  },
  {
    "TITLE": "Handling Subdomains with Nested Blueprints",
    "DESCRIPTION": "Illustrates how subdomains are handled when nesting blueprints, where the child's subdomain prefixes the parent's in the final URL.",
    "LANGUAGE": "python",
    "CODE": "```\nparent = Blueprint('parent', __name__, subdomain='parent')\nchild = Blueprint('child', __name__, subdomain='child')\nparent.register_blueprint(child)\napp.register_blueprint(parent)\n\nurl_for('parent.child.create', _external=True)\n\"child.parent.domain.tld\"\n```"
  },
  {
    "TITLE": "Accessing Blueprint Root Path",
    "DESCRIPTION": "Demonstrates how to access the `root_path` property of a Flask Blueprint to determine its resource folder on the filesystem.",
    "LANGUAGE": "python",
    "CODE": "```\nsimple_page.root_path\n'/Users/username/TestProject/yourapplication'\n```"
  },
  {
    "TITLE": "Configure uWSGI with Flask app factory pattern",
    "DESCRIPTION": "This snippet illustrates how to run uWSGI with a Flask application that uses the app factory pattern. It includes a Python file (`wsgi.py`) to create the application instance and the corresponding `uwsgi` command to point to this file.",
    "LANGUAGE": "python",
    "CODE": "```\nfrom hello import create_app\n\napp = create_app()\n```"
  },
  {
    "TITLE": "Registering a Child Blueprint on a Parent Blueprint",
    "DESCRIPTION": "Demonstrates how to register a child Blueprint on a parent Blueprint in Flask. The child's name and URLs will automatically gain the parent's prefix.",
    "LANGUAGE": "python",
    "CODE": "```\nparent = Blueprint('parent', __name__, url_prefix='/parent')\nchild = Blueprint('child', __name__, url_prefix='/child')\nparent.register_blueprint(child)\napp.register_blueprint(parent)\n```"
  },
  {
    "TITLE": "Flask Blueprint URL Generation (Absolute)",
    "DESCRIPTION": "Demonstrates how to generate a URL for an endpoint within a specific Flask Blueprint using the `url_for` function, by prefixing the endpoint with the blueprint name and a dot.",
    "LANGUAGE": "python",
    "CODE": "```\nurl_for('admin.index')\n```"
  },
  {
    "TITLE": "Manually Push Flask Application Context for Initialization",
    "DESCRIPTION": "This Python snippet demonstrates how to manually push an application context using `app.app_context()` within a `with` block. This is useful during application configuration, such as initializing a database, especially when using the app factory pattern where the `app` instance is not globally imported.",
    "LANGUAGE": "python",
    "CODE": "```\ndef create_app():\n        app = Flask(__name__)\n\n        with app.app_context():\n            init_db()\n\n        return app\n```"
  },
  {
    "TITLE": "Flask: Application-level 404 Handler for Blueprint URL Errors",
    "DESCRIPTION": "This Python snippet highlights that 404/405 error handlers defined on blueprints are only triggered by explicit `raise` or `abort` calls within the blueprint's views. For invalid URLs not owned by a blueprint, the handler must be defined at the application level to catch all such errors.",
    "LANGUAGE": "python",
    "CODE": "```\nfrom flask import jsonify, render_template\n\n# at the application level\n# not the blueprint level\n@app.errorhandler(404)\n```"
  },
  {
    "TITLE": "Flask Internal Context and Blueprint API",
    "DESCRIPTION": "This section documents internal Flask objects crucial for request and application context management, as well as blueprint setup. These are typically not directly accessed by application developers.",
    "LANGUAGE": "APIDOC",
    "CODE": "```\nclass flask.ctx.RequestContext\ndata flask.globals.request_ctx:\n  The current RequestContext. If a request context is not active, accessing attributes on this proxy will raise a RuntimeError.\n  This is an internal object that is essential to how Flask handles requests. Accessing this should not be needed in most cases. Most likely you want request and session instead.\n\nclass flask.ctx.AppContext\ndata flask.globals.app_ctx:\n  The current AppContext. If an app context is not active, accessing attributes on this proxy will raise a RuntimeError.\n  This is an internal object that is essential to how Flask handles requests. Accessing this should not be needed in most cases. Most likely you want current_app and g instead.\n\nclass flask.blueprints.BlueprintSetupState\n```"
  },
  {
    "TITLE": "Test Flask Application Configuration and Hello Route",
    "DESCRIPTION": "Tests the Flask application's configuration, ensuring the 'TESTING' flag works correctly, and verifies a basic 'hello' route returns the expected 'Hello, World!' response using the test client.",
    "LANGUAGE": "python",
    "CODE": "```\nfrom flaskr import create_app\n\n\ndef test_config():\n    assert not create_app().testing\n    assert create_app({'TESTING': True}).testing\n\n\ndef test_hello(client):\n    response = client.get('/hello')\n    assert response.data == b'Hello, World!'\n```"
  }
]
